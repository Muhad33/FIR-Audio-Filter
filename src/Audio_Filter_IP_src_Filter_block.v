// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\hdlcoder_audio_filter_biquad\Audio_Filter_IP_src_Filter_block.v
// Created: 2024-11-07 11:40:50
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Audio_Filter_IP_src_Filter_block
// Source Path: hdlcoder_audio_filter_biquad/Audio_Filter/Filter_block
// Hierarchy Level: 1
// Model version: 10.1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Audio_Filter_IP_src_Filter_block
          (clk,
           reset,
           enb,
           Data_in,
           Input_to_Switch,
           BiQuad_LPF,
           BiQuad_BPF,
           BiQuad_HPF,
           Enable,
           Data_out);


  input   clk;
  input   reset;
  input   enb;
  input   [47:0] Data_in;  // ufix48
  input   [7:0] Input_to_Switch;  // uint8
  input   BiQuad_LPF;
  input   BiQuad_BPF;
  input   BiQuad_HPF;
  input   Enable;
  output  [47:0] Data_out;  // ufix48


  reg  [27:0] delayMatch_reg;  // ufix1 [28]
  wire Enable_out6;
  reg [7:0] delayMatch_reg_1 [0:27];  // ufix8 [28]
  reg [7:0] delayMatch_reg_next [0:27];  // ufix8 [28]
  reg [7:0] Input_to_Switch_1;  // uint8
  wire signed [23:0] Data_Type_Conversion_In_out1;  // sfix24_En22
  reg signed [23:0] delayMatch_reg_2 [0:27];  // sfix24 [28]
  reg signed [23:0] delayMatch_reg_next_1 [0:27];  // sfix24_En22 [28]
  reg signed [23:0] Data_Type_Conversion_In_out1_1;  // sfix24_En22
  wire BiQuad_LPF_1;
  wire signed [23:0] BiQuad_LPF_out1;  // sfix24_En22
  wire BiQuad_BPF_1;
  wire signed [23:0] BiQuad_BPF_out1;  // sfix24_En22
  wire BiQuad_HPF_1;
  wire signed [23:0] BiQuad_HPF_out1;  // sfix24_En22
  reg signed [23:0] delayMatch_reg_3 [0:7];  // sfix24 [8]
  reg signed [23:0] delayMatch_reg_next_2 [0:7];  // sfix24_En22 [8]
  reg signed [23:0] BiQuad_HPF_out1_1;  // sfix24_En22
  wire signed [23:0] Multiport_Switch_out1;  // sfix24_En22
  wire [47:0] Data_Type_Conversion_Out_out1;  // ufix48
  wire [47:0] Data_Type_Conversion_Out_out1_bypass;  // ufix48
  reg [47:0] Data_Type_Conversion_Out_out1_last_value;  // ufix48
  reg signed [31:0] delayMatch_t_0_0;  // int32
  reg signed [31:0] delayMatch_t_0_1;  // int32
  reg signed [31:0] delayMatch_t_1;  // int32
  reg signed [31:0] delayMatch_t_0_01;  // int32
  reg signed [31:0] delayMatch_t_0_02;  // int32
  reg signed [31:0] delayMatch_t_0_1_1;  // int32
  reg signed [31:0] delayMatch_t_1_1;  // int32


  always @(posedge clk)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg <= {28{1'b0}};
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= Enable;
          delayMatch_reg[32'sd27:32'sd1] <= delayMatch_reg[32'sd26:32'sd0];
        end
      end
    end

  assign Enable_out6 = delayMatch_reg[27];

  always @(posedge clk)
    begin : delayMatch_1_process
      if (reset == 1'b1) begin
        for(delayMatch_t_1 = 32'sd0; delayMatch_t_1 <= 32'sd27; delayMatch_t_1 = delayMatch_t_1 + 32'sd1) begin
          delayMatch_reg_1[delayMatch_t_1] <= 8'b00000000;
        end
      end
      else begin
        if (enb) begin
          for(delayMatch_t_0_1 = 32'sd0; delayMatch_t_0_1 <= 32'sd27; delayMatch_t_0_1 = delayMatch_t_0_1 + 32'sd1) begin
            delayMatch_reg_1[delayMatch_t_0_1] <= delayMatch_reg_next[delayMatch_t_0_1];
          end
        end
      end
    end

  always @* begin
    Input_to_Switch_1 = delayMatch_reg_1[27];
    delayMatch_reg_next[0] = Input_to_Switch;

    for(delayMatch_t_0_0 = 32'sd0; delayMatch_t_0_0 <= 32'sd26; delayMatch_t_0_0 = delayMatch_t_0_0 + 32'sd1) begin
      delayMatch_reg_next[delayMatch_t_0_0 + 32'sd1] = delayMatch_reg_1[delayMatch_t_0_0];
    end

  end

  Audio_Filter_IP_src_Data_Type_Conversion_In u_Data_Type_Conversion_In (.In1(Data_in),  // ufix48
                                                                         .Out1(Data_Type_Conversion_In_out1)  // sfix24_En22
                                                                         );
  always @(posedge clk)
    begin : delayMatch_2_process
      if (reset == 1'b1) begin
        for(delayMatch_t_1 = 32'sd0; delayMatch_t_1 <= 32'sd27; delayMatch_t_1 = delayMatch_t_1 + 32'sd1) begin
          delayMatch_reg_2[delayMatch_t_1] <= 24'sb000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(delayMatch_t_0_1 = 32'sd0; delayMatch_t_0_1 <= 32'sd27; delayMatch_t_0_1 = delayMatch_t_0_1 + 32'sd1) begin
            delayMatch_reg_2[delayMatch_t_0_1] <= delayMatch_reg_next_1[delayMatch_t_0_1];
          end
        end
      end
    end

  always @* begin
    Data_Type_Conversion_In_out1_1 = delayMatch_reg_2[27];
    delayMatch_reg_next_1[0] = Data_Type_Conversion_In_out1;

    for(delayMatch_t_0_01 = 32'sd0; delayMatch_t_0_01 <= 32'sd26; delayMatch_t_0_01 = delayMatch_t_0_01 + 32'sd1) begin
      delayMatch_reg_next_1[delayMatch_t_0_01 + 32'sd1] = delayMatch_reg_2[delayMatch_t_0_01];
    end

  end

  assign BiQuad_LPF_1 = BiQuad_LPF & Enable;

  Audio_Filter_IP_src_BiQuad_LPF u_BiQuad_LPF (.clk(clk),
                                               .reset(reset),
                                               .enb(enb),
                                               .In1(Data_Type_Conversion_In_out1),  // sfix24_En22
                                               .Enable(BiQuad_LPF_1),
                                               .Out1(BiQuad_LPF_out1)  // sfix24_En22
                                               );
  assign BiQuad_BPF_1 = BiQuad_BPF & Enable;

  Audio_Filter_IP_src_BiQuad_BPF u_BiQuad_BPF (.clk(clk),
                                               .reset(reset),
                                               .enb(enb),
                                               .In1(Data_Type_Conversion_In_out1),  // sfix24_En22
                                               .Enable(BiQuad_BPF_1),
                                               .Out1(BiQuad_BPF_out1)  // sfix24_En22
                                               );
  assign BiQuad_HPF_1 = BiQuad_HPF & Enable;

  Audio_Filter_IP_src_BiQuad_HPF u_BiQuad_HPF (.clk(clk),
                                               .reset(reset),
                                               .enb(enb),
                                               .In1(Data_Type_Conversion_In_out1),  // sfix24_En22
                                               .Enable(BiQuad_HPF_1),
                                               .Out1(BiQuad_HPF_out1)  // sfix24_En22
                                               );
  always @(posedge clk)
    begin : delayMatch_3_process
      if (reset == 1'b1) begin
        for(delayMatch_t_1_1 = 32'sd0; delayMatch_t_1_1 <= 32'sd7; delayMatch_t_1_1 = delayMatch_t_1_1 + 32'sd1) begin
          delayMatch_reg_3[delayMatch_t_1_1] <= 24'sb000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(delayMatch_t_0_1_1 = 32'sd0; delayMatch_t_0_1_1 <= 32'sd7; delayMatch_t_0_1_1 = delayMatch_t_0_1_1 + 32'sd1) begin
            delayMatch_reg_3[delayMatch_t_0_1_1] <= delayMatch_reg_next_2[delayMatch_t_0_1_1];
          end
        end
      end
    end

  always @* begin
    BiQuad_HPF_out1_1 = delayMatch_reg_3[7];
    delayMatch_reg_next_2[0] = BiQuad_HPF_out1;

    for(delayMatch_t_0_02 = 32'sd0; delayMatch_t_0_02 <= 32'sd6; delayMatch_t_0_02 = delayMatch_t_0_02 + 32'sd1) begin
      delayMatch_reg_next_2[delayMatch_t_0_02 + 32'sd1] = delayMatch_reg_3[delayMatch_t_0_02];
    end

  end

  assign Multiport_Switch_out1 = (Input_to_Switch_1 == 8'b00000000 ? Data_Type_Conversion_In_out1_1 :
              (Input_to_Switch_1 == 8'b00000001 ? BiQuad_LPF_out1 :
              (Input_to_Switch_1 == 8'b00000010 ? BiQuad_BPF_out1 :
              BiQuad_HPF_out1_1)));
  Audio_Filter_IP_src_Data_Type_Conversion_Out u_Data_Type_Conversion_Out (.In1(Multiport_Switch_out1),  // sfix24_En22
                                                                           .Out1(Data_Type_Conversion_Out_out1)  // ufix48
                                                                           );
  always @(posedge clk)
    begin : Data_out_bypass_process
      if (reset == 1'b1) begin
        Data_Type_Conversion_Out_out1_last_value <= 48'h000000000000;
      end
      else begin
        if (enb) begin
          Data_Type_Conversion_Out_out1_last_value <= Data_Type_Conversion_Out_out1_bypass;
        end
      end
    end

  assign Data_Type_Conversion_Out_out1_bypass = (Enable_out6 == 1'b0 ? Data_Type_Conversion_Out_out1_last_value :
              Data_Type_Conversion_Out_out1);

  assign Data_out = Data_Type_Conversion_Out_out1_bypass;

endmodule  // Audio_Filter_IP_src_Filter_block

